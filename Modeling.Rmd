---
title: "Modeling"
author: "Michael Bostwick"
date: "2/7/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Modeling

```{r , echo=FALSE, include=FALSE}
setwd("/Users/michaelbostwick/Documents/Galapagos")

library(tidyverse)
library(ggplot2)
library(readxl)
library(glmnet)
library(mpath)
library(reshape2)
library(gridExtra)
library(leaps)

load("BASES_CENSO_UPA_spss/clean_data.RData")
vars <-  read_excel("Variables.xlsx", sheet = "vars", range = "C2:I241")

```

## Variable pre-selection

Check for highly correlated variables. Variables that have perfect or very high correlation will have one of the pair removed (marked as a "C" in the Variables spreadsheet).

```{r, echo=FALSE, warning=FALSE}
vars_include <- vars[which(is.na(vars$`Surface area with invasive species`)),1]$`Variable Name`
x_include <- subset(reduced_data, select =vars_include)

numeric_data <- model.matrix(~., x_include)[,-1]
corrs <-cor(numeric_data)
corrs[upper.tri(corrs)] <- NA
diag(corrs) <- NA

corrs_reshape <- melt(corrs, na.rm = TRUE)
(high_corrs <- corrs_reshape[abs(corrs_reshape$value) > 0.9,])

```

## UPA Production

```{r, echo=FALSE}
zero_prod <- reduced_data[reduced_data$productivity ==0,]
summary(zero_prod$netincome)
par(mfrow = c(2,1))
raw_prod_hist <- ggplot(data = reduced_data) + geom_histogram(mapping = aes(x = productivity))
log_prod_hist <- ggplot(data = reduced_data) + geom_histogram(mapping = aes(x = log10(productivity)))
lower_prod_hist <- ggplot(data = reduced_data) + geom_histogram(mapping = aes(x = productivity)) +
  xlim(0, 10000) + xlab("productivity (0-10,000)")
grid.arrange(raw_prod_hist, lower_prod_hist, log_prod_hist, nrow = 1, top = "Histogram of Productivity Response Variable")

```


```{r, echo=FALSE}


production_include <- vars[which(is.na(vars$`UPA Production`)),1]$`Variable Name`
production_x.df <- subset(reduced_data[reduced_data$productivity > 0,], select = production_include)
production_x <- model.matrix(~., production_x.df)[,-1]

log_productivity <- log10(reduced_data[reduced_data$productivity > 0, 'productivity'])

set.seed(1)
foldid=sample(1:10,size=length(log_productivity),replace=TRUE)
cv1=cv.glmnet(production_x,log_productivity,foldid=foldid,alpha=1)
cv.75=cv.glmnet(production_x,log_productivity,foldid=foldid,alpha=0.75)
cv.5=cv.glmnet(production_x,log_productivity,foldid=foldid,alpha=.5)
cv.25=cv.glmnet(production_x,log_productivity,foldid=foldid,alpha=0.25)
cv0=cv.glmnet(production_x,log_productivity,foldid=foldid,alpha=0)

cv1.mse <- cv1$cvm[cv1$lambda == cv1$lambda.1se]
cv.75.mse <- cv.75$cvm[cv.75$lambda == cv.75$lambda.1se]
cv.5.mse <- cv.5$cvm[cv.5$lambda == cv.5$lambda.1se]
cv.25.mse <- cv.25$cvm[cv.25$lambda == cv.25$lambda.1se]
cv0.mse <- cv0$cvm[cv0$lambda == cv0$lambda.1se]

par(mfrow=c(2,2))
plot(cv1,main="Alpha = 1");plot(cv.75,main="Alpha = 0.75");plot(cv.5,main="Alpha = 0.5");plot(cv0,main="Alpha = 0");
plot(log(cv1$lambda),cv1$cvm,pch=19,col="red",xlab="log(Lambda)",ylab=cv1$name,  main="Alpha = 1")
points(log(cv.5$lambda),cv.5$cvm,pch=19,col="grey", main="Alpha = 0.5")
points(log(cv0$lambda),cv0$cvm,pch=19,col="blue", main="Alpha = 0")
par(mfrow=c(1,1))

par(mfrow=c(2,1))
plot(cv1$glmnet.fit, s = cv1$lambda.1se, xvar = "dev", label = FALSE)
plot(cv.5$glmnet.fit, s = cv.5$lambda.1se, xvar = "dev", label = FALSE)

lasso.coef <- predict(cv1,type="coefficients",s=cv1$lambda.1se)[1:ncol(production_x),] 
lasso.coef[lasso.coef!=0]

cv.5.predicts <- predict(cv.5, newx = production_x,  type = "response", s = cv.5$lambda.1se)
cv.5.resids <- (log_productivity - cv.5.predicts)
plot(cv.5.predicts, cv.5.resids)



```

Alpha [0.25 - 1] all seem to exhibit similar predictive performance, alpha = 0.5 is chosen. Alpha = 0 has slightly higher error.


```{r, echo=FALSE}
set.seed(1)
bs_coefs <- data.frame(matrix(ncol = ncol(production_x)+1, nrow = 0))
colnames(bs_coefs) <- c("(Intercept)", colnames(production_x))

for (i in 1:1000){
  bootstrap_samples <- sample(1:nrow(production_x), size = nrow(production_x), replace = TRUE)
  weights <- table(factor(bootstrap_samples, levels = 1:nrow(production_x)))
  bs.elasticnet = glmnet(production_x,log_productivity,weights = weights,alpha=.5, lambda =  cv.5$lambda.1se)
  
  bs.coef <- t(data.frame(predict(bs.elasticnet,type="coefficients",s=bs.elasticnet$lambda.1se)[1:(ncol(production_x)+1),]))
  bs_coefs <- rbind(bs_coefs, bs.coef)
}

row.names(bs_coefs) <- c(seq(1:1000))



boxplot(bs_coefs[, abs(colSums(bs_coefs)) > 0.1])

pct_zeroes <- data.frame(colSums(bs_coefs != 0)/nrow(bs_coefs))
pct_zeroes <- rownames_to_column(pct_zeroes)
colnames(pct_zeroes) <- c("variable", "pct_zero")

ggplot(pct_zeroes[pct_zeroes$pct_zero < .01,]) + geom_bar(stat='identity', aes(x=variable, y=pct_zero)) + coord_flip()

ggplot(data = melt(bs_coefs[,51:100]), aes(x=variable, y=value)) + geom_boxplot() + coord_flip()
```

Limit boxplot to coefficients that are not zero

```{r, echo=FALSE}
best.fwd <- regsubsets(log_productivity~., data=production_x.df ,nvmax=200,method = "forward")
best.fwd.summary <- summary(best.fwd)

best.bwd <- regsubsets(log_productivity~., data=production_x.df ,nvmax=200,method = "backward")
best.bwd.summary <- summary(best.bwd)

plot_results <- function(select.summary1, select.summary2){
  par(mfrow=c(2,2))
  plot(select.summary1$cp ,xlab="Number of Variables ",ylab="Cp", type='l')
  min.cp <- which.min(select.summary1$cp)
  points(min.cp,select.summary1$cp[min.cp],col="red",cex=2,pch=20)
  
  plot(select.summary1$bic ,xlab="Number of Variables ",ylab="BIC", type='l')
  min.bic <- which.min(select.summary1$bic)
  points(min.bic,select.summary1$bic[min.bic],col="red",cex=2,pch=20)
  
  plot(select.summary2$cp ,xlab="Number of Variables ",ylab="Cp", type='l')
  min.cp <- which.min(select.summary2$cp)
  points(min.cp,select.summary2$cp[min.cp],col="blue",cex=2,pch=20)
  
  plot(select.summary2$bic ,xlab="Number of Variables ",ylab="BIC", type='l')
  min.bic <- which.min(select.summary2$bic)
  points(min.bic,select.summary2$bic[min.bic],col="blue",cex=2,pch=20)
  
  par(mfrow=c(1,1))
}

plot_results(best.fwd.summary, best.bwd.summary)

fwd.coefs <- coef(best.fwd, which.min(best.fwd.summary$bic))
incl_vars <- names(fwd.coefs)[-1]

incl_x <- production_x[,incl_vars]


fwd.predicts <- incl_x %*% fwd.coefs[-1] + fwd.coefs[1]
fwd.resids <- (log_productivity - fwd.predicts)


plot(fwd.predicts, fwd.resids)
```


